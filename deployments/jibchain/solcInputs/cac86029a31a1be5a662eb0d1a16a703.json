{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nabstract contract ComptrollerInterface {\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\n  bool public constant isComptroller = true;\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata jTokens) external virtual returns (uint[] memory);\n\n  function exitMarket(address jToken) external virtual returns (uint);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(address jToken, address minter, uint mintAmount) external virtual returns (uint);\n\n  function mintVerify(address jToken, address minter, uint mintAmount, uint mintTokens) external virtual;\n\n  function redeemAllowed(address jToken, address redeemer, uint redeemTokens) external virtual returns (uint);\n\n  function redeemVerify(\n    address jToken,\n    address redeemer,\n    uint redeemAmount,\n    uint redeemTokens\n  ) external virtual;\n\n  function borrowAllowed(address jToken, address borrower, uint borrowAmount) external virtual returns (uint);\n\n  function borrowVerify(address jToken, address borrower, uint borrowAmount) external virtual;\n\n  function repayBorrowAllowed(\n    address jToken,\n    address payer,\n    address borrower,\n    uint repayAmount\n  ) external virtual returns (uint);\n\n  function repayBorrowVerify(\n    address jToken,\n    address payer,\n    address borrower,\n    uint repayAmount,\n    uint borrowerIndex\n  ) external virtual;\n\n  function liquidateBorrowAllowed(\n    address jTokenBorrowed,\n    address jTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint repayAmount\n  ) external virtual returns (uint);\n\n  function liquidateBorrowVerify(\n    address jTokenBorrowed,\n    address jTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint repayAmount,\n    uint seizeTokens\n  ) external virtual;\n\n  function seizeAllowed(\n    address jTokenCollateral,\n    address jTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external virtual returns (uint);\n\n  function seizeVerify(\n    address jTokenCollateral,\n    address jTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external virtual;\n\n  function transferAllowed(\n    address jToken,\n    address src,\n    address dst,\n    uint transferTokens\n  ) external virtual returns (uint);\n\n  function transferVerify(address jToken, address src, address dst, uint transferTokens) external virtual;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidateCalculateSeizeTokens(\n    address jTokenBorrowed,\n    address jTokenCollateral,\n    uint repayAmount\n  ) external view virtual returns (uint, uint);\n}\n"
    },
    "contracts/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n      * @notice Get the total number of tokens in circulation\n      * @return The supply of tokens\n      */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success Whether or not the transfer succeeded\n      */\n    function transfer(address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success Whether or not the transfer succeeded\n      */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return success Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return success Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining The number of tokens allowed to be spent\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract ComptrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        COMPTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    uint public constant NO_ERROR = 0; // support legacy return codes\n\n    error TransferComptrollerRejection(uint256 errorCode);\n    error TransferNotAllowed();\n    error TransferNotEnough();\n    error TransferTooMuch();\n\n    error MintComptrollerRejection(uint256 errorCode);\n    error MintFreshnessCheck();\n\n    error RedeemComptrollerRejection(uint256 errorCode);\n    error RedeemFreshnessCheck();\n    error RedeemTransferOutNotPossible();\n\n    error BorrowComptrollerRejection(uint256 errorCode);\n    error BorrowFreshnessCheck();\n    error BorrowCashNotAvailable();\n\n    error RepayBorrowComptrollerRejection(uint256 errorCode);\n    error RepayBorrowFreshnessCheck();\n\n    error LiquidateComptrollerRejection(uint256 errorCode);\n    error LiquidateFreshnessCheck();\n    error LiquidateCollateralFreshnessCheck();\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\n    error LiquidateLiquidatorIsBorrower();\n    error LiquidateCloseAmountIsZero();\n    error LiquidateCloseAmountIsUintMax();\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\n\n    error LiquidateSeizeComptrollerRejection(uint256 errorCode);\n    error LiquidateSeizeLiquidatorIsBorrower();\n\n    error AcceptAdminPendingAdminCheck();\n\n    error SetComptrollerOwnerCheck();\n    error SetPendingAdminOwnerCheck();\n\n    error SetReserveFactorAdminCheck();\n    error SetReserveFactorFreshCheck();\n    error SetReserveFactorBoundsCheck();\n\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\n\n    error ReduceReservesAdminCheck();\n    error ReduceReservesFreshCheck();\n    error ReduceReservesCashNotAvailable();\n    error ReduceReservesCashValidation();\n\n    error SetInterestRateModelOwnerCheck();\n    error SetInterestRateModelFreshCheck();\n}\n"
    },
    "contracts/ExperimentalPythPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./PriceOracle.sol\";\nimport \"./JErc20.sol\";\nimport \"./EIP20Interface.sol\";\n\ncontract ExperimentalPythPriceOracle is Ownable, PriceOracle {\n  IPyth pyth;\n\n  mapping(address => uint) prices; // 1e18\n  mapping(address => bytes32) priceIds;\n\n  event SetDirectPrice(address asset, uint price);\n  event SetPricePythId(address asset, bytes32 priceId);\n\n  constructor(address _pyth) Ownable(msg.sender) {\n    pyth = IPyth(_pyth);\n  }\n\n  function _getUnderlyingAddress(JToken jToken) private view returns (address) {\n    address asset;\n    if (compareStrings(jToken.symbol(), \"jJBC\")) {\n      asset = 0x4200000000000000000000000000000000000006; // change this to actual WETH address\n    } else {\n      asset = address(JErc20(address(jToken)).underlying());\n    }\n    return asset;\n  }\n\n  function getUnderlyingPrice(JToken jToken) public view override returns (uint) {\n    address asset = _getUnderlyingAddress(jToken);\n    uint price = prices[asset];\n    if (priceIds[asset] != bytes32(0)) {\n      PythStructs.Price memory currentPythPrice = pyth.getPriceUnsafe(priceIds[asset]);\n      price = convertToUint(currentPythPrice, 18 + 18 - EIP20Interface(asset).decimals());\n    }\n    return price;\n  }\n\n  function getAssetPrice(address asset) public view override returns (uint) {\n    uint price = prices[asset];\n    if (priceIds[asset] != bytes32(0)) {\n      PythStructs.Price memory currentPythPrice = pyth.getPriceUnsafe(priceIds[asset]);\n      price = convertToUint(currentPythPrice, 18 + 18 - EIP20Interface(asset).decimals());\n    }\n    return price;\n  }\n\n  function setUnderlyingDirectPrice(JToken jToken, uint price) public onlyOwner {\n    emit SetDirectPrice(address(jToken), price);\n    prices[_getUnderlyingAddress(jToken)] = price;\n  }\n\n  function setAssetDirectPrice(address asset, uint price) public onlyOwner {\n    emit SetDirectPrice(asset, price);\n    prices[asset] = price;\n  }\n\n  function setUnderlyingPythPriceId(JToken jToken, bytes32 priceId) public onlyOwner {\n    address asset = _getUnderlyingAddress(jToken);\n    emit SetPricePythId(address(asset), priceId);\n    prices[asset] = 0;\n    priceIds[asset] = priceId;\n  }\n\n  function setAssetPythPriceId(address asset, bytes32 priceId) public onlyOwner {\n    emit SetPricePythId(asset, priceId);\n    prices[asset] = 0;\n    priceIds[asset] = priceId;\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function convertToUint(\n    PythStructs.Price memory price,\n    uint8 targetDecimals\n  ) internal pure returns (uint256) {\n    if (price.price < 0 || price.expo > 0 || price.expo < -255) {\n      revert(\"!P\"); // Invalid price\n    }\n\n    uint8 priceDecimals = uint8(uint32(-1 * price.expo));\n\n    if (targetDecimals >= priceDecimals) {\n      return uint(uint64(price.price)) * 10 ** uint32(targetDecimals - priceDecimals);\n    } else {\n      return uint(uint64(price.price)) / 10 ** uint32(priceDecimals - targetDecimals);\n    }\n  }\n}\n"
    },
    "contracts/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author JLEND\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint constant expScale = 1e18;\n  uint constant doubleScale = 1e36;\n  uint constant halfExpScale = expScale / 2;\n  uint constant mantissaOne = expScale;\n\n  struct Exp {\n    uint mantissa;\n  }\n\n  struct Double {\n    uint mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint scalar) internal pure returns (uint) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) internal pure returns (uint) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2 ** 224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2 ** 32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(uint a, uint b) internal pure returns (uint) {\n    return a + b;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(uint a, uint b) internal pure returns (uint) {\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n  }\n\n  function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\n    return Exp({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Exp memory b) internal pure returns (uint) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n  }\n\n  function mul_(Double memory a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Double memory b) internal pure returns (uint) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint a, uint b) internal pure returns (uint) {\n    return a * b;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n  }\n\n  function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\n    return Exp({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Exp memory b) internal pure returns (uint) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n  }\n\n  function div_(Double memory a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Double memory b) internal pure returns (uint) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint a, uint b) internal pure returns (uint) {\n    return a / b;\n  }\n\n  function fraction(uint a, uint b) internal pure returns (Double memory) {\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\n  }\n}\n"
    },
    "contracts/Governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract GovernorAlpha {\n  /// @notice The name of this contract\n  string public constant name = \"JLEND Governor Alpha\";\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  function quorumVotes() public pure returns (uint) {\n    return 400000e18;\n  } // 400,000 = 4% of JLEND\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  function proposalThreshold() public pure returns (uint) {\n    return 100000e18;\n  } // 100,000 = 1% of JLEND\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  function proposalMaxOperations() public pure returns (uint) {\n    return 10;\n  } // 10 actions\n\n  /// @notice The delay before voting on a proposal may take place, once proposed\n  function votingDelay() public pure returns (uint) {\n    return 1;\n  } // 1 block\n\n  /// @notice The duration of voting on a proposal, in blocks\n  function votingPeriod() public pure virtual returns (uint) {\n    return 17280;\n  } // ~3 days in blocks (assuming 15s blocks)\n\n  /// @notice The address of the JLEND Protocol Timelock\n  TimelockInterface public timelock;\n\n  /// @notice The address of the JLEND governance token\n  JLendInterface public jLend;\n\n  /// @notice The address of the Governor Guardian\n  address public guardian;\n\n  /// @notice The total number of proposals\n  uint public proposalCount;\n\n  struct Proposal {\n    /// @notice Unique id for looking up a proposal\n    uint id;\n    /// @notice Creator of the proposal\n    address proposer;\n    /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint eta;\n    /// @notice the ordered list of target addresses for calls to be made\n    address[] targets;\n    /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint[] values;\n    /// @notice The ordered list of function signatures to be called\n    string[] signatures;\n    /// @notice The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n    uint startBlock;\n    /// @notice The block at which voting ends: votes must be cast prior to this block\n    uint endBlock;\n    /// @notice Current number of votes in favor of this proposal\n    uint forVotes;\n    /// @notice Current number of votes in opposition to this proposal\n    uint againstVotes;\n    /// @notice Flag marking whether the proposal has been canceled\n    bool canceled;\n    /// @notice Flag marking whether the proposal has been executed\n    bool executed;\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n\n  /// @notice Ballot receipt record for a voter\n  struct Receipt {\n    /// @notice Whether or not a vote has been cast\n    bool hasVoted;\n    /// @notice Whether or not the voter supports the proposal\n    bool support;\n    /// @notice The number of votes the voter had, which were cast\n    uint96 votes;\n  }\n\n  /// @notice Possible states that a proposal may be in\n  enum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n  }\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint) public latestProposalIds;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n  /// @notice An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint id,\n    address proposer,\n    address[] targets,\n    uint[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint startBlock,\n    uint endBlock,\n    string description\n  );\n\n  /// @notice An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint proposalId, bool support, uint votes);\n\n  /// @notice An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint id);\n\n  /// @notice An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint id, uint eta);\n\n  /// @notice An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint id);\n\n  constructor(address timelock_, address jLend_, address guardian_) public {\n    timelock = TimelockInterface(timelock_);\n    jLend = JLendInterface(jLend_);\n    guardian = guardian_;\n  }\n\n  function propose(\n    address[] memory targets,\n    uint[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint) {\n    require(\n      jLend.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length &&\n        targets.length == signatures.length &&\n        targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n      );\n    }\n\n    uint startBlock = add256(block.number, votingDelay());\n    uint endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    uint proposalId = proposalCount;\n    Proposal storage newProposal = proposals[proposalId];\n    // This should never happen but add a check in case.\n    require(newProposal.id == 0, \"GovernorAlpha::propose: ProposalID collsion\");\n    newProposal.id = proposalId;\n    newProposal.proposer = msg.sender;\n    newProposal.eta = 0;\n    newProposal.targets = targets;\n    newProposal.values = values;\n    newProposal.signatures = signatures;\n    newProposal.calldatas = calldatas;\n    newProposal.startBlock = startBlock;\n    newProposal.endBlock = endBlock;\n    newProposal.forVotes = 0;\n    newProposal.againstVotes = 0;\n    newProposal.canceled = false;\n    newProposal.executed = false;\n\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      startBlock,\n      endBlock,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint proposalId) public {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint eta = add256(block.timestamp, timelock.delay());\n    for (uint i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        eta\n      );\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint value,\n    string memory signature,\n    bytes memory data,\n    uint eta\n  ) internal {\n    require(\n      !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    timelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint proposalId) public payable {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint i = 0; i < proposal.targets.length; i++) {\n      timelock.executeTransaction{value: proposal.values[i]}(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint proposalId) public {\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      msg.sender == guardian ||\n        jLend.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(),\n      \"GovernorAlpha::cancel: proposer above threshold\"\n    );\n\n    proposal.canceled = true;\n    for (uint i = 0; i < proposal.targets.length; i++) {\n      timelock.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(\n    uint proposalId\n  )\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint proposalId) public view returns (ProposalState) {\n    require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n    );\n    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n    return _castVote(signatory, proposalId, support);\n  }\n\n  function _castVote(address voter, uint proposalId, bool support) internal {\n    require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n    uint96 votes = jLend.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function __acceptAdmin() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n    timelock.acceptAdmin();\n  }\n\n  function __abdicate() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n    guardian = address(0);\n  }\n\n  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n    require(\n      msg.sender == guardian,\n      \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\"\n    );\n    timelock.queueTransaction(\n      address(timelock),\n      0,\n      \"setPendingAdmin(address)\",\n      abi.encode(newPendingAdmin),\n      eta\n    );\n  }\n\n  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n    require(\n      msg.sender == guardian,\n      \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\"\n    );\n    timelock.executeTransaction(\n      address(timelock),\n      0,\n      \"setPendingAdmin(address)\",\n      abi.encode(newPendingAdmin),\n      eta\n    );\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, \"addition overflow\");\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint) {\n    require(b <= a, \"subtraction underflow\");\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint) {\n    uint chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n\ninterface TimelockInterface {\n  function delay() external view returns (uint);\n\n  function GRACE_PERIOD() external view returns (uint);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint value,\n    string calldata signature,\n    bytes calldata data,\n    uint eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint value,\n    string calldata signature,\n    bytes calldata data,\n    uint eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint value,\n    string calldata signature,\n    bytes calldata data,\n    uint eta\n  ) external payable returns (bytes memory);\n}\n\ninterface JLendInterface {\n  function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/Governance/JLEND.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract JLEND {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"JLEND Token\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"JLEND\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint public constant totalSupply = 10000000e18; // 10 million JLend\n\n  /// @notice Allowance amounts on behalf of others\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  /// @notice Official record of token balances for each account\n  mapping(address => uint96) internal balances;\n\n  /// @notice A record of each accounts delegate\n  mapping(address => address) public delegates;\n\n  /// @notice A checkpoint for marking number of votes from a given block\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  /// @notice A record of votes checkpoints for each account, by index\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  /// @notice The number of checkpoints for each account\n  mapping(address => uint32) public numCheckpoints;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the delegation struct used by the contract\n  bytes32 public constant DELEGATION_TYPEHASH =\n    keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n  /// @notice A record of states for signing / validating signatures\n  mapping(address => uint) public nonces;\n\n  /// @notice An event thats emitted when an account changes its delegate\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n  /// @notice An event thats emitted when a delegate account's vote balance changes\n  event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n  /// @notice The standard EIP-20 transfer event\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /// @notice The standard EIP-20 approval event\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /**\n   * @notice Construct a new JLend token\n   * @param account The initial account to grant all the tokens\n   */\n  constructor(address account) public {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  /**\n   * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n   * @param account The address of the account holding the funds\n   * @param spender The address of the account spending the funds\n   * @return The number of tokens approved\n   */\n  function allowance(address account, address spender) external view returns (uint) {\n    return allowances[account][spender];\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == type(uint).max) {\n      amount = type(uint96).max;\n    } else {\n      amount = safe96(rawAmount, \"JLend::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the number of tokens held by the `account`\n   * @param account The address of the account to get the balance of\n   * @return The number of tokens held\n   */\n  function balanceOf(address account) external view returns (uint) {\n    return balances[account];\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"JLend::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"JLend::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != type(uint96).max) {\n      uint96 newAllowance = sub96(\n        spenderAllowance,\n        amount,\n        \"JLend::transferFrom: transfer amount exceeds spender allowance\"\n      );\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Delegate votes from `msg.sender` to `delegatee`\n   * @param delegatee The address to delegate votes to\n   */\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  /**\n   * @notice Delegates votes from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n    );\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"JLend::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"JLend::delegateBySig: invalid nonce\");\n    require(block.timestamp <= expiry, \"JLend::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  /**\n   * @notice Gets the current votes balance for `account`\n   * @param account The address to get votes balance\n   * @return The number of current votes for `account`\n   */\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  /**\n   * @notice Determine the prior number of votes for an account as of a block number\n   * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n   * @param account The address of the account to check\n   * @param blockNumber The block number to get the vote balance at\n   * @return The number of votes the account had as of the given block\n   */\n  function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n    require(blockNumber < block.number, \"JLend::getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(address src, address dst, uint96 amount) internal {\n    require(src != address(0), \"JLend::_transferTokens: cannot transfer from the zero address\");\n    require(dst != address(0), \"JLend::_transferTokens: cannot transfer to the zero address\");\n\n    balances[src] = sub96(balances[src], amount, \"JLend::_transferTokens: transfer amount exceeds balance\");\n    balances[dst] = add96(balances[dst], amount, \"JLend::_transferTokens: transfer amount overflows\");\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n        uint96 srcRepNew = sub96(srcRepOld, amount, \"JLend::_moveVotes: vote amount underflows\");\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n        uint96 dstRepNew = add96(dstRepOld, amount, \"JLend::_moveVotes: vote amount overflows\");\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(block.number, \"JLend::_writeCheckpoint: block number exceeds 32 bits\");\n\n    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2 ** 32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n    require(n < 2 ** 96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n"
    },
    "contracts/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title JLEND's InterestRateModel Interface\n * @author JLEND\n */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(uint cash, uint borrows, uint reserves) external view virtual returns (uint);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint cash,\n    uint borrows,\n    uint reserves,\n    uint reserveFactorMantissa\n  ) external view virtual returns (uint);\n}\n"
    },
    "contracts/JErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./JToken.sol\";\n\ninterface JLendLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title JLEND's JErc20 Contract\n * @notice JTokens which wrap an EIP-20 underlying\n * @author JLEND\n */\ncontract JErc20 is JToken, JErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) public {\n    // JToken initialize does the bulk of the work\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives jTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint mintAmount) external override returns (uint) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems jTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of jTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint redeemTokens) external override returns (uint) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems jTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint redeemAmount) external override returns (uint) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint borrowAmount) external override returns (uint) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint repayAmount) external override returns (uint) {\n    repayBorrowInternal(repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint repayAmount) external override returns (uint) {\n    repayBorrowBehalfInternal(borrower, repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this jToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param jTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint repayAmount,\n    JTokenInterface jTokenCollateral\n  ) external override returns (uint) {\n    liquidateBorrowInternal(borrower, repayAmount, jTokenCollateral);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n   * @param token The address of the ERC-20 token to sweep\n   */\n  function sweepToken(EIP20NonStandardInterface token) external override {\n    require(msg.sender == admin, \"JErc20::sweepToken: only admin can sweep tokens\");\n    require(address(token) != underlying, \"JErc20::sweepToken: can not sweep underlying token\");\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n   * @param addAmount The amount fo underlying token to add as reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint addAmount) external override returns (uint) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(address from, uint amount) internal virtual override returns (uint) {\n    // Read from storage once\n    address underlying_ = underlying;\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n    uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n    // Calculate the amount that was *actually* transferred\n    uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(address payable to, uint amount) internal virtual override {\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n    token.transfer(to, amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {\n        // This is a non-standard ERC-20\n        success := not(0) // set success to true\n      }\n      case 32 {\n        // This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0) // Set `success = returndata` of override external call\n      }\n      default {\n        // This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the JLEND-like underlying\n   * @param jLendLikeDelegatee The address to delegate votes to\n   * @dev JTokens whose underlying are not JLendLike should revert here\n   */\n  function _delegateJLendLikeTo(address jLendLikeDelegatee) external {\n    require(msg.sender == admin, \"only the admin may set the jLend-like delegate\");\n    JLendLike(underlying).delegate(jLendLikeDelegatee);\n  }\n}\n"
    },
    "contracts/JToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./JTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title JLEND's JToken Contract\n * @notice Abstract base for JTokens\n * @author JLEND\n */\nabstract contract JToken is JTokenInterface, ExponentialNoError, TokenErrorReporter {\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) public {\n    require(msg.sender == admin, \"only admin may initialize the market\");\n    require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n    // Set the comptroller\n    uint err = _setComptroller(comptroller_);\n    require(err == NO_ERROR, \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == NO_ERROR, \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return 0 if the transfer succeeded, else revert\n   */\n  function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n    /* Fail if transfer not allowed */\n    uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      revert TransferComptrollerRejection(allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      revert TransferNotAllowed();\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    uint allowanceNew = startingAllowance - tokens;\n    uint srjTokensNew = accountTokens[src] - tokens;\n    uint dstTokensNew = accountTokens[dst] + tokens;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srjTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (uint256.max means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint) {\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account) external view override returns (uint, uint, uint, uint) {\n    return (\n      NO_ERROR,\n      accountTokens[account],\n      borrowBalanceStoredInternal(account),\n      exchangeRateStoredInternal()\n    );\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view virtual returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this jToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint) {\n    return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this jToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external override nonReentrant returns (uint) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view override returns (uint) {\n    return borrowBalanceStoredInternal(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n    return principalTimesIndex / borrowSnapshot.interestIndex;\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant returns (uint) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the JToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint) {\n    return exchangeRateStoredInternal();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the JToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStoredInternal() internal view virtual returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint totalCash = getCashPrior();\n      uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n      uint exchangeRate = (cashPlusBorrowsMinusReserves * expScale) / _totalSupply;\n\n      return exchangeRate;\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this jToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint) {\n    /* Remember the initial block number */\n    uint currentBlockNumber = getBlockNumber();\n    uint accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return NO_ERROR;\n    }\n\n    /* Read the previous values out of storage */\n    uint cashPrior = getCashPrior();\n    uint borrowsPrior = totalBorrows;\n    uint reservesPrior = totalReserves;\n    uint borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n    require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n    uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n    uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n    uint totalReservesNew = mul_ScalarTruncateAddUInt(\n      Exp({mantissa: reserveFactorMantissa}),\n      interestAccumulated,\n      reservesPrior\n    );\n    uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives jTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintInternal(uint mintAmount) internal nonReentrant {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    mintFresh(msg.sender, mintAmount);\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives jTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintFresh(address minter, uint mintAmount) internal {\n    /* Fail if mint not allowed */\n    uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      revert MintComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert MintFreshnessCheck();\n    }\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The jToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the jToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of jTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n     * We calculate the new total supply of jTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     * And write them into storage\n     */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n  }\n\n  /**\n   * @notice Sender redeems jTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of jTokens to redeem into underlying\n   */\n  function redeemInternal(uint redeemTokens) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems jTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming jTokens\n   */\n  function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), 0, redeemAmount);\n  }\n\n  /**\n   * @notice User redeems jTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of jTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming jTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   */\n  function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\n    require(\n      redeemTokensIn == 0 || redeemAmountIn == 0,\n      \"one of redeemTokensIn or redeemAmountIn must be zero\"\n    );\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint redeemTokens;\n    uint redeemAmount;\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      redeemTokens = redeemTokensIn;\n      redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n      redeemTokens = div_(redeemAmountIn, exchangeRate);\n      redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n    if (allowed != 0) {\n      revert RedeemComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RedeemFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < redeemAmount) {\n      revert RedeemTransferOutNotPossible();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We write the previously calculated values into storage.\n     *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n     */\n    totalSupply = totalSupply - redeemTokens;\n    accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The jToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the jToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), redeemTokens);\n    emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowInternal(uint borrowAmount) internal nonReentrant {\n    accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    borrowFresh(payable(msg.sender), borrowAmount);\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowFresh(address payable borrower, uint borrowAmount) internal {\n    /* Fail if borrow not allowed */\n    uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      revert BorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert BorrowFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    if (getCashPrior() < borrowAmount) {\n      revert BorrowCashNotAvailable();\n    }\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowNew = accountBorrow + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n    uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n    uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The jToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the jToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n   * @return (uint) the actual repayment amount.\n   */\n  function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n    /* Fail if repayBorrow not allowed */\n    uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      revert RepayBorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RepayBorrowFreshnessCheck();\n    }\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The jToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the jToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n    uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n    return actualRepayAmount;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this jToken to be liquidated\n   * @param jTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint repayAmount,\n    JTokenInterface jTokenCollateral\n  ) internal nonReentrant {\n    accrueInterest();\n\n    uint error = jTokenCollateral.accrueInterest();\n    if (error != NO_ERROR) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      revert LiquidateAccrueCollateralInterestFailed(error);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    liquidateBorrowFresh(msg.sender, borrower, repayAmount, jTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this jToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param jTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint repayAmount,\n    JTokenInterface jTokenCollateral\n  ) internal {\n    /* Fail if liquidate not allowed */\n    uint allowed = comptroller.liquidateBorrowAllowed(\n      address(this),\n      address(jTokenCollateral),\n      liquidator,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      revert LiquidateComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert LiquidateFreshnessCheck();\n    }\n\n    /* Verify jTokenCollateral market's block number equals current block number */\n    if (jTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      revert LiquidateCollateralFreshnessCheck();\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateLiquidatorIsBorrower();\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      revert LiquidateCloseAmountIsZero();\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint).max) {\n      revert LiquidateCloseAmountIsUintMax();\n    }\n\n    /* Fail if repayBorrow fails */\n    uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n      address(this),\n      address(jTokenCollateral),\n      actualRepayAmount\n    );\n    require(amountSeizeError == NO_ERROR, \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(jTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    if (address(jTokenCollateral) == address(this)) {\n      seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      require(jTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, \"token seizure failed\");\n    }\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(jTokenCollateral), seizeTokens);\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another jToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed jToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of jTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external override nonReentrant returns (uint) {\n    seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another JToken.\n   *  Its absolutely critical to use msg.sender as the seizer jToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed jToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of jTokens to seize\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) internal {\n    /* Fail if seize not allowed */\n    uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n    if (allowed != 0) {\n      revert LiquidateSeizeComptrollerRejection(allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateSeizeLiquidatorIsBorrower();\n    }\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    uint protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\n    uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n    uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\n    uint totalReservesNew = totalReserves + protocolSeizeAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the calculated values into storage */\n    totalReserves = totalReservesNew;\n    totalSupply = totalSupply - protocolSeizeTokens;\n    accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n    accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), protocolSeizeTokens);\n    emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      revert SetPendingAdminOwnerCheck();\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() external override returns (uint) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      revert AcceptAdminPendingAdminCheck();\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = payable(address(0));\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Admin function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(ComptrollerInterface newComptroller) public override returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetComptrollerOwnerCheck();\n    }\n\n    ComptrollerInterface oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(newComptroller.isComptroller(), \"marker method returned false\");\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint newReserveFactorMantissa) external override nonReentrant returns (uint) {\n    accrueInterest();\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetReserveFactorAdminCheck();\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetReserveFactorFreshCheck();\n    }\n\n    // Check newReserveFactor  maxReserveFactor\n    if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n      revert SetReserveFactorBoundsCheck();\n    }\n\n    uint oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring from msg.sender\n   * @param addAmount Amount of addition to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n    accrueInterest();\n\n    // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n    _addReservesFresh(addAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Add reserves by transferring from caller\n   * @dev Requires fresh interest accrual\n   * @param addAmount Amount of addition to reserves\n   * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n   */\n  function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n    // totalReserves + actualAddAmount\n    uint totalReservesNew;\n    uint actualAddAmount;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert AddReservesFactorFreshCheck(actualAddAmount);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the caller and the addAmount\n     *  Note: The jToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the jToken holds an additional addAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *  it returns the amount actually transferred, in case of a fee.\n     */\n\n    actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n    totalReservesNew = totalReserves + actualAddAmount;\n\n    // Store reserves[n+1] = reserves[n] + actualAddAmount\n    totalReserves = totalReservesNew;\n\n    /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n    emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n    /* Return (NO_ERROR, actualAddAmount) */\n    return (NO_ERROR, actualAddAmount);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint reduceAmount) external override nonReentrant returns (uint) {\n    accrueInterest();\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n    // totalReserves - reduceAmount\n    uint totalReservesNew;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert ReduceReservesAdminCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert ReduceReservesFreshCheck();\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      revert ReduceReservesCashNotAvailable();\n    }\n\n    // Check reduceAmount  reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      revert ReduceReservesCashValidation();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    totalReservesNew = totalReserves - reduceAmount;\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(admin, reduceAmount);\n\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint) {\n    accrueInterest();\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n   * @dev Admin function to update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n    // Used to store old model for use in the event that is emitted on success\n    InterestRateModel oldInterestRateModel;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetInterestRateModelOwnerCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetInterestRateModelFreshCheck();\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    return NO_ERROR;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying owned by this contract\n   */\n  function getCashPrior() internal view virtual returns (uint);\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n   *  This may revert due to insufficient balance or insufficient allowance.\n   */\n  function doTransferIn(address from, uint amount) internal virtual returns (uint);\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n   */\n  function doTransferOut(address payable to, uint amount) internal virtual;\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n}\n"
    },
    "contracts/JTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ErrorReporter.sol\";\n\ncontract JTokenStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  // Maximum borrow rate that can ever be applied (.0005% / block)\n  uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  // Maximum fraction of interest that can be set aside for reserves\n  uint internal constant reserveFactorMaxMantissa = 1e18;\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address payable public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address payable public pendingAdmin;\n\n  /**\n   * @notice Contract which oversees inter-jToken operations\n   */\n  ComptrollerInterface public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  // Initial exchange rate used when minting the first JTokens (used when totalSupply = 0)\n  uint internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint public totalReserves;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint public totalSupply;\n\n  // Official record of token balances for each account\n  mapping(address => uint) internal accountTokens;\n\n  // Approved token transfer amounts on behalf of others\n  mapping(address => mapping(address => uint)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint principal;\n    uint interestIndex;\n  }\n\n  // Mapping of account addresses to outstanding borrow balances\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /**\n   * @notice Share of seized collateral that is added to reserves\n   */\n  uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n}\n\nabstract contract JTokenInterface is JTokenStorage {\n  /**\n   * @notice Indicator that this is a JToken contract (for inspection)\n   */\n  bool public constant isJToken = true;\n\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint mintAmount, uint mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint repayAmount,\n    uint accountBorrows,\n    uint totalBorrows\n  );\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint repayAmount,\n    address jTokenCollateral,\n    uint seizeTokens\n  );\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Event emitted when comptroller is changed\n   */\n  event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(\n    InterestRateModel oldInterestRateModel,\n    InterestRateModel newInterestRateModel\n  );\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint amount);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint amount);\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint amount) external virtual returns (bool);\n\n  function transferFrom(address src, address dst, uint amount) external virtual returns (bool);\n\n  function approve(address spender, uint amount) external virtual returns (bool);\n\n  function allowance(address owner, address spender) external view virtual returns (uint);\n\n  function balanceOf(address owner) external view virtual returns (uint);\n\n  function balanceOfUnderlying(address owner) external virtual returns (uint);\n\n  function getAccountSnapshot(address account) external view virtual returns (uint, uint, uint, uint);\n\n  function borrowRatePerBlock() external view virtual returns (uint);\n\n  function supplyRatePerBlock() external view virtual returns (uint);\n\n  function totalBorrowsCurrent() external virtual returns (uint);\n\n  function borrowBalanceCurrent(address account) external virtual returns (uint);\n\n  function borrowBalanceStored(address account) external view virtual returns (uint);\n\n  function exchangeRateCurrent() external virtual returns (uint);\n\n  function exchangeRateStored() external view virtual returns (uint);\n\n  function getCash() external view virtual returns (uint);\n\n  function accrueInterest() external virtual returns (uint);\n\n  function seize(address liquidator, address borrower, uint seizeTokens) external virtual returns (uint);\n\n  /*** Admin Functions ***/\n\n  function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint);\n\n  function _acceptAdmin() external virtual returns (uint);\n\n  function _setComptroller(ComptrollerInterface newComptroller) external virtual returns (uint);\n\n  function _setReserveFactor(uint newReserveFactorMantissa) external virtual returns (uint);\n\n  function _reduceReserves(uint reduceAmount) external virtual returns (uint);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) external virtual returns (uint);\n}\n\ncontract JErc20Storage {\n  /**\n   * @notice Underlying asset for this JToken\n   */\n  address public underlying;\n}\n\nabstract contract JErc20Interface is JErc20Storage {\n  /*** User Interface ***/\n\n  function mint(uint mintAmount) external virtual returns (uint);\n\n  function redeem(uint redeemTokens) external virtual returns (uint);\n\n  function redeemUnderlying(uint redeemAmount) external virtual returns (uint);\n\n  function borrow(uint borrowAmount) external virtual returns (uint);\n\n  function repayBorrow(uint repayAmount) external virtual returns (uint);\n\n  function repayBorrowBehalf(address borrower, uint repayAmount) external virtual returns (uint);\n\n  function liquidateBorrow(\n    address borrower,\n    uint repayAmount,\n    JTokenInterface jTokenCollateral\n  ) external virtual returns (uint);\n\n  function sweepToken(EIP20NonStandardInterface token) external virtual;\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint addAmount) external virtual returns (uint);\n}\n\ncontract CDelegationStorage {\n  /**\n   * @notice Implementation address for this contract\n   */\n  address public implementation;\n}\n\nabstract contract CDelegatorInterface is CDelegationStorage {\n  /**\n   * @notice Emitted when implementation is changed\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) external virtual;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @dev Should revert if any issues arise which make it unfit for delegation\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes memory data) external virtual;\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n   */\n  function _resignImplementation() external virtual;\n}\n"
    },
    "contracts/Lens/JLendLens.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../JErc20.sol\";\nimport \"../JToken.sol\";\nimport \"../PriceOracle.sol\";\nimport \"../EIP20Interface.sol\";\nimport \"../Governance/GovernorAlpha.sol\";\nimport \"../Governance/JLEND.sol\";\n\ninterface ComptrollerLensInterface {\n  function markets(address) external view returns (bool, uint);\n\n  function oracle() external view returns (PriceOracle);\n\n  function getAccountLiquidity(address) external view returns (uint, uint, uint);\n\n  function getAssetsIn(address) external view returns (JToken[] memory);\n\n  function claimJLend(address) external;\n\n  function jLendAccrued(address) external view returns (uint);\n\n  function jLendSpeeds(address) external view returns (uint);\n\n  function jLendSupplySpeeds(address) external view returns (uint);\n\n  function jLendBorrowSpeeds(address) external view returns (uint);\n\n  function borrowCaps(address) external view returns (uint);\n}\n\ninterface GovernorBravoInterface {\n  struct Receipt {\n    bool hasVoted;\n    uint8 support;\n    uint96 votes;\n  }\n  struct Proposal {\n    uint id;\n    address proposer;\n    uint eta;\n    uint startBlock;\n    uint endBlock;\n    uint forVotes;\n    uint againstVotes;\n    uint abstainVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function getActions(\n    uint proposalId\n  )\n    external\n    view\n    returns (\n      address[] memory targets,\n      uint[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n\n  function proposals(uint proposalId) external view returns (Proposal memory);\n\n  function getReceipt(uint proposalId, address voter) external view returns (Receipt memory);\n}\n\ncontract JLendLens {\n  struct JTokenMetadata {\n    address jToken;\n    uint exchangeRateCurrent;\n    uint supplyRatePerBlock;\n    uint borrowRatePerBlock;\n    uint reserveFactorMantissa;\n    uint totalBorrows;\n    uint totalReserves;\n    uint totalSupply;\n    uint totalCash;\n    bool isListed;\n    uint collateralFactorMantissa;\n    address underlyingAssetAddress;\n    uint jTokenDecimals;\n    uint underlyingDecimals;\n    uint jLendSupplySpeed;\n    uint jLendBorrowSpeed;\n    uint borrowCap;\n  }\n\n  function getJLendSpeeds(ComptrollerLensInterface comptroller, JToken jToken) internal returns (uint, uint) {\n    // Getting jLend speeds is gnarly due to not every network having the\n    // split jLend speeds from Proposal 62 and other networks don't even\n    // have jLend speeds.\n    uint jLendSupplySpeed = 0;\n    (bool jLendSupplySpeedSuccess, bytes memory jLendSupplySpeedReturnData) = address(comptroller).call(\n      abi.encodePacked(comptroller.jLendSupplySpeeds.selector, abi.encode(address(jToken)))\n    );\n    if (jLendSupplySpeedSuccess) {\n      jLendSupplySpeed = abi.decode(jLendSupplySpeedReturnData, (uint));\n    }\n\n    uint jLendBorrowSpeed = 0;\n    (bool jLendBorrowSpeedSuccess, bytes memory jLendBorrowSpeedReturnData) = address(comptroller).call(\n      abi.encodePacked(comptroller.jLendBorrowSpeeds.selector, abi.encode(address(jToken)))\n    );\n    if (jLendBorrowSpeedSuccess) {\n      jLendBorrowSpeed = abi.decode(jLendBorrowSpeedReturnData, (uint));\n    }\n\n    // If the split jLend speeds call doesn't work, try the  oldest non-spit version.\n    if (!jLendSupplySpeedSuccess || !jLendBorrowSpeedSuccess) {\n      (bool jLendSpeedSuccess, bytes memory jLendSpeedReturnData) = address(comptroller).call(\n        abi.encodePacked(comptroller.jLendSpeeds.selector, abi.encode(address(jToken)))\n      );\n      if (jLendSpeedSuccess) {\n        jLendSupplySpeed = jLendBorrowSpeed = abi.decode(jLendSpeedReturnData, (uint));\n      }\n    }\n    return (jLendSupplySpeed, jLendBorrowSpeed);\n  }\n\n  function jTokenMetadata(JToken jToken) public returns (JTokenMetadata memory) {\n    uint exchangeRateCurrent = jToken.exchangeRateCurrent();\n    ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(jToken.comptroller()));\n    (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(jToken));\n    address underlyingAssetAddress;\n    uint underlyingDecimals;\n\n    if (compareStrings(jToken.symbol(), \"jJBC\")) {\n      underlyingAssetAddress = address(0);\n      underlyingDecimals = 18;\n    } else {\n      JErc20 cErc20 = JErc20(address(jToken));\n      underlyingAssetAddress = cErc20.underlying();\n      underlyingDecimals = EIP20Interface(cErc20.underlying()).decimals();\n    }\n\n    (uint jLendSupplySpeed, uint jLendBorrowSpeed) = getJLendSpeeds(comptroller, jToken);\n\n    uint borrowCap = 0;\n    (bool borrowCapSuccess, bytes memory borrowCapReturnData) = address(comptroller).call(\n      abi.encodePacked(comptroller.borrowCaps.selector, abi.encode(address(jToken)))\n    );\n    if (borrowCapSuccess) {\n      borrowCap = abi.decode(borrowCapReturnData, (uint));\n    }\n\n    return\n      JTokenMetadata({\n        jToken: address(jToken),\n        exchangeRateCurrent: exchangeRateCurrent,\n        supplyRatePerBlock: jToken.supplyRatePerBlock(),\n        borrowRatePerBlock: jToken.borrowRatePerBlock(),\n        reserveFactorMantissa: jToken.reserveFactorMantissa(),\n        totalBorrows: jToken.totalBorrows(),\n        totalReserves: jToken.totalReserves(),\n        totalSupply: jToken.totalSupply(),\n        totalCash: jToken.getCash(),\n        isListed: isListed,\n        collateralFactorMantissa: collateralFactorMantissa,\n        underlyingAssetAddress: underlyingAssetAddress,\n        jTokenDecimals: jToken.decimals(),\n        underlyingDecimals: underlyingDecimals,\n        jLendSupplySpeed: jLendSupplySpeed,\n        jLendBorrowSpeed: jLendBorrowSpeed,\n        borrowCap: borrowCap\n      });\n  }\n\n  function jTokenMetadataAll(JToken[] calldata jTokens) external returns (JTokenMetadata[] memory) {\n    uint jTokenCount = jTokens.length;\n    JTokenMetadata[] memory res = new JTokenMetadata[](jTokenCount);\n    for (uint i = 0; i < jTokenCount; i++) {\n      res[i] = jTokenMetadata(jTokens[i]);\n    }\n    return res;\n  }\n\n  struct JTokenBalances {\n    address jToken;\n    uint balanceOf;\n    uint borrowBalanceCurrent;\n    uint balanceOfUnderlying;\n    uint tokenBalance;\n    uint tokenAllowance;\n  }\n\n  function jTokenBalances(JToken jToken, address payable account) public returns (JTokenBalances memory) {\n    uint balanceOf = jToken.balanceOf(account);\n    uint borrowBalanceCurrent = jToken.borrowBalanceCurrent(account);\n    uint balanceOfUnderlying = jToken.balanceOfUnderlying(account);\n    uint tokenBalance;\n    uint tokenAllowance;\n\n    if (compareStrings(jToken.symbol(), \"jJBC\")) {\n      tokenBalance = account.balance;\n      tokenAllowance = account.balance;\n    } else {\n      JErc20 cErc20 = JErc20(address(jToken));\n      EIP20Interface underlying = EIP20Interface(cErc20.underlying());\n      tokenBalance = underlying.balanceOf(account);\n      tokenAllowance = underlying.allowance(account, address(jToken));\n    }\n\n    return\n      JTokenBalances({\n        jToken: address(jToken),\n        balanceOf: balanceOf,\n        borrowBalanceCurrent: borrowBalanceCurrent,\n        balanceOfUnderlying: balanceOfUnderlying,\n        tokenBalance: tokenBalance,\n        tokenAllowance: tokenAllowance\n      });\n  }\n\n  function jTokenBalancesAll(\n    JToken[] calldata jTokens,\n    address payable account\n  ) external returns (JTokenBalances[] memory) {\n    uint jTokenCount = jTokens.length;\n    JTokenBalances[] memory res = new JTokenBalances[](jTokenCount);\n    for (uint i = 0; i < jTokenCount; i++) {\n      res[i] = jTokenBalances(jTokens[i], account);\n    }\n    return res;\n  }\n\n  struct JTokenUnderlyingPrice {\n    address jToken;\n    uint underlyingPrice;\n  }\n\n  function jTokenUnderlyingPrice(JToken jToken) public returns (JTokenUnderlyingPrice memory) {\n    ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(jToken.comptroller()));\n    PriceOracle priceOracle = comptroller.oracle();\n\n    return\n      JTokenUnderlyingPrice({\n        jToken: address(jToken),\n        underlyingPrice: priceOracle.getUnderlyingPrice(jToken)\n      });\n  }\n\n  function jTokenUnderlyingPriceAll(\n    JToken[] calldata jTokens\n  ) external returns (JTokenUnderlyingPrice[] memory) {\n    uint jTokenCount = jTokens.length;\n    JTokenUnderlyingPrice[] memory res = new JTokenUnderlyingPrice[](jTokenCount);\n    for (uint i = 0; i < jTokenCount; i++) {\n      res[i] = jTokenUnderlyingPrice(jTokens[i]);\n    }\n    return res;\n  }\n\n  struct AccountLimits {\n    JToken[] markets;\n    uint liquidity;\n    uint shortfall;\n  }\n\n  function getAccountLimits(\n    ComptrollerLensInterface comptroller,\n    address account\n  ) public returns (AccountLimits memory) {\n    (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\n    require(errorCode == 0);\n\n    return\n      AccountLimits({markets: comptroller.getAssetsIn(account), liquidity: liquidity, shortfall: shortfall});\n  }\n\n  struct GovReceipt {\n    uint proposalId;\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  function getGovReceipts(\n    GovernorAlpha governor,\n    address voter,\n    uint[] memory proposalIds\n  ) public view returns (GovReceipt[] memory) {\n    uint proposalCount = proposalIds.length;\n    GovReceipt[] memory res = new GovReceipt[](proposalCount);\n    for (uint i = 0; i < proposalCount; i++) {\n      GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovReceipt({\n        proposalId: proposalIds[i],\n        hasVoted: receipt.hasVoted,\n        support: receipt.support,\n        votes: receipt.votes\n      });\n    }\n    return res;\n  }\n\n  struct GovBravoReceipt {\n    uint proposalId;\n    bool hasVoted;\n    uint8 support;\n    uint96 votes;\n  }\n\n  function getGovBravoReceipts(\n    GovernorBravoInterface governor,\n    address voter,\n    uint[] memory proposalIds\n  ) public view returns (GovBravoReceipt[] memory) {\n    uint proposalCount = proposalIds.length;\n    GovBravoReceipt[] memory res = new GovBravoReceipt[](proposalCount);\n    for (uint i = 0; i < proposalCount; i++) {\n      GovernorBravoInterface.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovBravoReceipt({\n        proposalId: proposalIds[i],\n        hasVoted: receipt.hasVoted,\n        support: receipt.support,\n        votes: receipt.votes\n      });\n    }\n    return res;\n  }\n\n  struct GovProposal {\n    uint proposalId;\n    address proposer;\n    uint eta;\n    address[] targets;\n    uint[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint startBlock;\n    uint endBlock;\n    uint forVotes;\n    uint againstVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setProposal(GovProposal memory res, GovernorAlpha governor, uint proposalId) internal view {\n    (\n      ,\n      address proposer,\n      uint eta,\n      uint startBlock,\n      uint endBlock,\n      uint forVotes,\n      uint againstVotes,\n      bool canceled,\n      bool executed\n    ) = governor.proposals(proposalId);\n    res.proposalId = proposalId;\n    res.proposer = proposer;\n    res.eta = eta;\n    res.startBlock = startBlock;\n    res.endBlock = endBlock;\n    res.forVotes = forVotes;\n    res.againstVotes = againstVotes;\n    res.canceled = canceled;\n    res.executed = executed;\n  }\n\n  function getGovProposals(\n    GovernorAlpha governor,\n    uint[] calldata proposalIds\n  ) external view returns (GovProposal[] memory) {\n    GovProposal[] memory res = new GovProposal[](proposalIds.length);\n    for (uint i = 0; i < proposalIds.length; i++) {\n      (\n        address[] memory targets,\n        uint[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n      ) = governor.getActions(proposalIds[i]);\n      res[i] = GovProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct GovBravoProposal {\n    uint proposalId;\n    address proposer;\n    uint eta;\n    address[] targets;\n    uint[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint startBlock;\n    uint endBlock;\n    uint forVotes;\n    uint againstVotes;\n    uint abstainVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setBravoProposal(\n    GovBravoProposal memory res,\n    GovernorBravoInterface governor,\n    uint proposalId\n  ) internal view {\n    GovernorBravoInterface.Proposal memory p = governor.proposals(proposalId);\n\n    res.proposalId = proposalId;\n    res.proposer = p.proposer;\n    res.eta = p.eta;\n    res.startBlock = p.startBlock;\n    res.endBlock = p.endBlock;\n    res.forVotes = p.forVotes;\n    res.againstVotes = p.againstVotes;\n    res.abstainVotes = p.abstainVotes;\n    res.canceled = p.canceled;\n    res.executed = p.executed;\n  }\n\n  function getGovBravoProposals(\n    GovernorBravoInterface governor,\n    uint[] calldata proposalIds\n  ) external view returns (GovBravoProposal[] memory) {\n    GovBravoProposal[] memory res = new GovBravoProposal[](proposalIds.length);\n    for (uint i = 0; i < proposalIds.length; i++) {\n      (\n        address[] memory targets,\n        uint[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n      ) = governor.getActions(proposalIds[i]);\n      res[i] = GovBravoProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        abstainVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setBravoProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct JLendBalanceMetadata {\n    uint balance;\n    uint votes;\n    address delegate;\n  }\n\n  function getJLendBalanceMetadata(\n    JLEND jLend,\n    address account\n  ) external view returns (JLendBalanceMetadata memory) {\n    return\n      JLendBalanceMetadata({\n        balance: jLend.balanceOf(account),\n        votes: uint256(jLend.getCurrentVotes(account)),\n        delegate: jLend.delegates(account)\n      });\n  }\n\n  struct JLendBalanceMetadataExt {\n    uint balance;\n    uint votes;\n    address delegate;\n    uint allocated;\n  }\n\n  function getJLendBalanceMetadataExt(\n    JLEND jLend,\n    ComptrollerLensInterface comptroller,\n    address account\n  ) external returns (JLendBalanceMetadataExt memory) {\n    uint balance = jLend.balanceOf(account);\n    comptroller.claimJLend(account);\n    uint newBalance = jLend.balanceOf(account);\n    uint accrued = comptroller.jLendAccrued(account);\n    uint total = add(accrued, newBalance, \"sum jLend total\");\n    uint allocated = sub(total, balance, \"sub allocated\");\n\n    return\n      JLendBalanceMetadataExt({\n        balance: balance,\n        votes: uint256(jLend.getCurrentVotes(account)),\n        delegate: jLend.delegates(account),\n        allocated: allocated\n      });\n  }\n\n  struct JLendVotes {\n    uint blockNumber;\n    uint votes;\n  }\n\n  function getJLendVotes(\n    JLEND jLend,\n    address account,\n    uint32[] calldata blockNumbers\n  ) external view returns (JLendVotes[] memory) {\n    JLendVotes[] memory res = new JLendVotes[](blockNumbers.length);\n    for (uint i = 0; i < blockNumbers.length; i++) {\n      res[i] = JLendVotes({\n        blockNumber: uint256(blockNumbers[i]),\n        votes: uint256(jLend.getPriorVotes(account, blockNumbers[i]))\n      });\n    }\n    return res;\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n    return c;\n  }\n}\n"
    },
    "contracts/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./JToken.sol\";\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n   * @notice Get the underlying price of a jToken asset\n   * @param jToken The jToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(JToken jToken) external view virtual returns (uint);\n\n  /**\n   * @notice Get the price of a specific asset\n   * @param asset The asset to get the price of\n   * @return The asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getAssetPrice(address asset) external view virtual returns (uint);\n}\n"
    },
    "contracts/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./PriceOracle.sol\";\nimport \"./JErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle {\n  mapping(address => uint) prices;\n  event PricePosted(\n    address asset,\n    uint previousPriceMantissa,\n    uint requestedPriceMantissa,\n    uint newPriceMantissa\n  );\n\n  function _getUnderlyingAddress(JToken jToken) private view returns (address) {\n    address asset;\n    if (compareStrings(jToken.symbol(), \"jETH\")) {\n      asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    } else {\n      asset = address(JErc20(address(jToken)).underlying());\n    }\n    return asset;\n  }\n\n  function getUnderlyingPrice(JToken jToken) public view override returns (uint) {\n    return prices[_getUnderlyingAddress(jToken)];\n  }\n\n  // v1 price oracle interface for use as backing of proxy\n  function getAssetPrice(address asset) public view override returns (uint) {\n    return prices[asset];\n  }\n\n  function setUnderlyingPrice(JToken jToken, uint underlyingPriceMantissa) public {\n    address asset = _getUnderlyingAddress(jToken);\n    emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n    prices[asset] = underlyingPriceMantissa;\n  }\n\n  function setDirectPrice(address asset, uint price) public {\n    emit PricePosted(asset, prices[asset], price, price);\n    prices[asset] = price;\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}